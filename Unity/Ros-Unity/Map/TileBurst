using UnityEngine;
using Unity.Burst;
using Unity.Mathematics;
using Unity.Jobs;
using Unity.Collections;
using System;
using UnityEngine.Rendering;
using System.Runtime.InteropServices;

public class TileBurst : MonoBehaviour
{
    public int tileX;
    public int tileY;
    public int tileCellWidth;
    public int tileCellHeight;
    public int startX;
    public int startY;
    public float resolution;
    public Vector3[] verts;
    public RectTransform rt;

    public Color[] colors;
    Vector3 localPosition;

    Mesh mesh;
    [SerializeField] MeshFilter meshFilter;
    [SerializeField] MeshCollider meshCollider;

    public void Init(int TileX, int TileY, int TileW, int TileH, float Resolution)
    {
        tileX = TileX;
        tileY = TileY;
        tileCellWidth = TileW;
        tileCellHeight = TileH;
        startX = TileX * 32;
        startY = TileY * 32;
        resolution = Resolution;
        localPosition = new Vector3(-rt.sizeDelta.x / 2, -rt.sizeDelta.y / 2, 0);

        BuildMesh();
    }

    void BuildMesh()
    {
        mesh = new Mesh();
        mesh.indexFormat = IndexFormat.UInt32;

        int vertCount = tileCellHeight * tileCellWidth * 4;
        int triCount = tileCellWidth * tileCellHeight * 6;

        var layout = new VertexAttributeDescriptor[]
        {
            new VertexAttributeDescriptor(
                VertexAttribute.Position, VertexAttributeFormat.Float32, 3, 0){  },
            new VertexAttributeDescriptor(
                VertexAttribute.Color, VertexAttributeFormat.UNorm8, 4, 1),
        };
        mesh.SetVertexBufferParams(vertCount, layout);
        mesh.SetIndexBufferParams(triCount, IndexFormat.UInt32);

        VertexNative = new NativeArray<Vector3>(vertCount, Allocator.Persistent);
        ColorNative = new NativeArray<Color32>(vertCount, Allocator.Persistent);

        int[] tris = new int[triCount];

        int vi = 0;
        int ti = 0;
        for (int y = 0; y < tileCellHeight; y++)
        {
            float py = localPosition.y + y * resolution;

            for (int x = 0; x < tileCellWidth; x++)
            {
                float px = localPosition.x + x * resolution;
                VertexNative[vi + 0] = new Vector3(px, py, 0);
                VertexNative[vi + 1] = new Vector3(px, py + resolution, 0);
                VertexNative[vi + 2] = new Vector3(px + resolution, py + resolution, 0);
                VertexNative[vi + 3] = new Vector3(px + resolution, py, 0);

                ColorNative[vi + 0] = new Color32(0, 0, 0, 255);
                ColorNative[vi + 1] = new Color32(255, 255, 255, 255);
                ColorNative[vi + 2] = new Color32(0, 0, 255, 255);
                ColorNative[vi + 3] = new Color32(128, 128, 128, 128);

                tris[ti + 0] = vi;
                tris[ti + 1] = vi + 1;
                tris[ti + 2] = vi + 2;

                tris[ti + 3] = vi;
                tris[ti + 4] = vi + 2;
                tris[ti + 5] = vi + 3;

                vi += 4;
                ti += 6;
            }
        }

        mesh.SetVertexBufferData(VertexNative, 0, 0, VertexNative.Length, 0);

        mesh.SetVertexBufferData(ColorNative, 0, 0, ColorNative.Length, 1);

        mesh.SetIndexBufferData(tris, 0, 0, tris.Length);
        mesh.subMeshCount = 1;
        mesh.SetSubMesh(0, new SubMeshDescriptor(0, tris.Length));
        meshFilter.sharedMesh = mesh;
        meshCollider.sharedMesh = mesh;
    }

    public void RefreshFromPatch(
        PatchMath.PatchTransform_Burst patch,
        int patchHorCellCount,
        Vector2 mapOriginPos,
        float mapOriginQuat,
        float resolution,
        int mapWidth,
        Span<sbyte> occupancyData)
    {
        Debug.Log(name + " has Refresh!");

        if (!OccNative.IsCreated || OccNative.Length != occupancyData.Length)
            OccNative = new NativeArray<sbyte>(occupancyData.Length, Allocator.Persistent);
        Span<sbyte> target = OccNative.AsSpan();
        occupancyData.CopyTo(target);

        var job = new PatchRefreshJob
        {
            occupancyData = OccNative,
            colors = ColorNative,

            patch = patch,
            mapCos = Mathf.Cos(mapOriginQuat * Mathf.Deg2Rad),
            mapSin = Mathf.Sin(mapOriginQuat * Mathf.Deg2Rad),
            resolution = resolution,
            mapOriginPos = mapOriginPos,
            offsetCorrectAfterTranslateCs = new float2(0.5f * resolution, 0.5f * resolution),

            tileCellWidth = this.tileCellWidth,
            tileCellHeight = this.tileCellHeight,
            startX = this.startX,
            startY = this.startY,
            patchHorCellCount = patchHorCellCount,
            mapWidth = mapWidth
        };

        for (int index = 0, len = tileCellWidth * tileCellHeight; index < len; index++)
        {
            job.Execute(index);
        }

        // if use below code snip, cancel the note with "[NativeDisableParallelForRestriction]" of "PatchRefreshJob"
        /* JobHandle handle = job.Schedule(tileCellWidth * tileCellHeight, 64);
          handle.Complete(); */
    }


    public void ApplyIfDirty()
    {
        Debug.Log(name + " has change!");
        mesh.SetVertexBufferData(
            ColorNative, 0, 0, ColorNative.Length, 1, MeshUpdateFlags.DontRecalculateBounds);

    }

    NativeArray<Vector3> VertexNative;
    NativeArray<sbyte> OccNative;
    NativeArray<Color32> ColorNative;

    private void OnDestroy()
    {
        if (VertexNative.IsCreated) VertexNative.Dispose();
        if (ColorNative.IsCreated) ColorNative.Dispose();
    }
}

[BurstCompile]
public struct PatchRefreshJob : IJobParallelFor
{
    [ReadOnly] public NativeArray<sbyte> occupancyData;
    // [NativeDisableParallelForRestriction]
    [WriteOnly] public NativeArray<Color32> colors;

    public PatchMath.PatchTransform_Burst patch;

    public float mapCos;
    public float mapSin;
    public float resolution;
    public float2 mapOriginPos;
    public float2 offsetCorrectAfterTranslateCs;

    public int tileCellWidth;
    public int tileCellHeight;
    public int startX;
    public int startY;
    public int patchHorCellCount;
    public int mapWidth;

    public void Execute(int index)
    {
        int localY = index / tileCellWidth;
        int localX = index % tileCellWidth;

        if (localY >= tileCellHeight) return;
        if (localX >= tileCellWidth) return;

        int mapX = startX + localX;
        int mapY = startY + localY;

        float mx = mapX * resolution;
        float my = mapY * resolution;

        float wx = mapOriginPos.x + (mapCos * mx - mapSin * my);
        float wy = mapOriginPos.y + (mapSin * mx + mapCos * my);

        //Debug.Log(index);
        float2 pLocal = PatchMath.WorldToPatchLocal_Burst(patch, wx, wy) + offsetCorrectAfterTranslateCs;
        if (pLocal.x >= 0f && pLocal.x < patch.widthMeters && pLocal.y >= 0 && pLocal.y < patch.heightMeters)
        {
            int cellX = (int)(pLocal.x / resolution);
            int cellY = (int)(pLocal.y / resolution);

            int idx = cellY * patchHorCellCount + cellX;
            sbyte v = occupancyData[idx];

            Color32 c;
            if (v < 0) c = new Color32(128, 128, 128, 255);
            else if (v == 100) c = new Color32(255, 0, 0, 255);
            else c = new Color32(0, 0, 0, 255);

            int cellIndex = localY * tileCellWidth + localX;
            int vi = cellIndex * 4;
            colors[vi + 0] = c;
            colors[vi + 1] = c;
            colors[vi + 2] = c;
            colors[vi + 3] = c;
        }
    }
}
